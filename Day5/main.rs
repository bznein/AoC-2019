fn extract_digit(num: i32, div: i32) -> i32 {
    (num / div) % 10
}

fn get_parameter(v: &[i32], position: i32, digit: i32, instruction: i32) -> i32 {
    match extract_digit(instruction, digit) {
        1 => position,
        0 => v[position as usize],
        _ => 0,
    }
}

fn execute(mut v: Vec<i32>, input : i32)
{
    let mut i = 0;
    while i < v.len() {
        let instruction = v[i];
        let op_code = v[i] % 100;
        if op_code == 99 {
            break;
        }
        let v1 = v[i + 1] as usize;
        let mut jumped = false;
        match op_code {
            1 => {
                let v3 = v[i + 3] as usize;
                v[v3] = get_parameter(&v, v[i + 1], 100, instruction)
                    + get_parameter(&v, v[i + 2], 1000, instruction)
            }
            2 => {
                let v3 = v[i + 3] as usize;
                v[v3] = get_parameter(&v, v[i + 1], 100, instruction)
                    * get_parameter(&v, v[i + 2], 1000, instruction)
            }
            3 => v[v1] = input,
            4 => println!("Result: {}", get_parameter(&v, v[i + 1], 100, instruction)),
            5 => {
                if get_parameter(&v, v[i + 1], 100, instruction) != 0 {
                    i = get_parameter(&v, v[i + 2], 1000, instruction) as usize;
                    jumped = true;
                }
            }
            6 => {
                if get_parameter(&v, v[i + 1], 100, instruction) == 0 {
                    i = get_parameter(&v, v[i + 2], 1000, instruction) as usize;
                    jumped = true;
                }
            }
            7 => {
                let v3 = v[i + 3] as usize;
                if get_parameter(&v, v[i + 1], 100, instruction)
                    < get_parameter(&v, v[i + 2], 1000, instruction)
                {
                    v[v3] = 1;
                } else {
                    v[v3] = 0;
                }
            }
            8 => {
                let v3 = v[i + 3] as usize;
                if get_parameter(&v, v[i + 1], 100, instruction)
                    == get_parameter(&v, v[i + 2], 1000, instruction)
                {
                    v[v3] = 1;
                } else {
                    v[v3] = 0;
                }
            }
            99 => break,
            _ => (),
        }
        if !jumped {
            i += match op_code {
                1 | 2 | 7 | 8 => 4,
                3 | 4 => 2,
                5 | 6 => 3,
                _ => 0,
            };
        }
        }
}

fn main() {
    let input = String::from("3,225,1,225,6,6,1100,1,238,225,104,0,1002,43,69,224,101,-483,224,224,4,224,1002,223,8,223,1001,224,5,224,1,224,223,223,1101,67,60,225,1102,5,59,225,1101,7,16,225,1102,49,72,225,101,93,39,224,101,-98,224,224,4,224,102,8,223,223,1001,224,6,224,1,224,223,223,1102,35,82,225,2,166,36,224,101,-4260,224,224,4,224,102,8,223,223,101,5,224,224,1,223,224,223,102,66,48,224,1001,224,-4752,224,4,224,102,8,223,223,1001,224,2,224,1,223,224,223,1001,73,20,224,1001,224,-55,224,4,224,102,8,223,223,101,7,224,224,1,223,224,223,1102,18,41,224,1001,224,-738,224,4,224,102,8,223,223,101,6,224,224,1,224,223,223,1101,68,71,225,1102,5,66,225,1101,27,5,225,1101,54,63,224,1001,224,-117,224,4,224,102,8,223,223,1001,224,2,224,1,223,224,223,1,170,174,224,101,-71,224,224,4,224,1002,223,8,223,1001,224,4,224,1,223,224,223,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,1007,226,226,224,1002,223,2,223,1006,224,329,1001,223,1,223,1007,226,677,224,102,2,223,223,1006,224,344,1001,223,1,223,108,677,677,224,102,2,223,223,1005,224,359,1001,223,1,223,1007,677,677,224,1002,223,2,223,1006,224,374,101,1,223,223,8,677,226,224,1002,223,2,223,1006,224,389,101,1,223,223,7,226,226,224,1002,223,2,223,1005,224,404,101,1,223,223,7,677,226,224,102,2,223,223,1005,224,419,1001,223,1,223,8,226,677,224,1002,223,2,223,1005,224,434,101,1,223,223,1008,226,677,224,102,2,223,223,1006,224,449,1001,223,1,223,7,226,677,224,1002,223,2,223,1006,224,464,1001,223,1,223,108,677,226,224,102,2,223,223,1005,224,479,101,1,223,223,108,226,226,224,1002,223,2,223,1006,224,494,101,1,223,223,8,226,226,224,1002,223,2,223,1005,224,509,1001,223,1,223,1107,677,226,224,102,2,223,223,1005,224,524,1001,223,1,223,1107,226,226,224,102,2,223,223,1005,224,539,1001,223,1,223,1108,677,677,224,1002,223,2,223,1006,224,554,101,1,223,223,107,226,677,224,102,2,223,223,1005,224,569,1001,223,1,223,1108,226,677,224,1002,223,2,223,1005,224,584,1001,223,1,223,1107,226,677,224,1002,223,2,223,1005,224,599,1001,223,1,223,1008,226,226,224,1002,223,2,223,1005,224,614,101,1,223,223,107,226,226,224,102,2,223,223,1006,224,629,1001,223,1,223,1008,677,677,224,1002,223,2,223,1006,224,644,101,1,223,223,107,677,677,224,1002,223,2,223,1005,224,659,101,1,223,223,1108,677,226,224,1002,223,2,223,1006,224,674,1001,223,1,223,4,223,99,226");
    let mut v: Vec<i32> = input
        .split(',')
        .map(|x| x.parse::<i32>().unwrap())
        .collect();
    
    println!("Part 1");
    execute(v.clone(),1);
    println!("\n\nPart2 ");
    
    execute(v.clone(),5);
}
